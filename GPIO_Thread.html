<!DOCTYPE html>
<HTML>
<head>
<title>GPIO_Thread</title>
<META NAME="AUTHOR" CONTENT="Jamie Boyd">
</head>
<H2>Documentation for GPIO Thread</H2>

GPIO_Thread is a collection of different projects that subclass the pulsedThread class to control the GPIO peripheral hardware on the Raspberry Pi. These include general purpose pulses or trains of pulses, pulse trains specialized for certain hardware, and special functions like controlling the PWM peripheral. For each project, XX the general organization is:
<ul>
	<li>XX.cpp/XX.h pair describing a C++ class that subclasses pulsedThread</li>
	<li>XX_tester.cpp, or XX_runner.cpp, that makes a small stand-alone application using XX, mostly for testing purposes</li>
	<li>XX_Py.cpp file that describes a Python/C module, ptXX, that wraps the C++ class methods with Python calls</li>
	<li>often, PTXX.py that provides a "Pythonic" object interface to the Python/C module</li>
	<li>XX_setup.py that builds and installs the Python/C module and, if present, XX.py</li>
	<li>Occasionally, PTXX_tester.py that tests some of the functions of the Python module</li>
</ul>

<p>The timing and threading is controlled by the functions provided by pulsedThread.  All of the pulsedThread functions for getting and setting timing and number of pulses can be used in the subclasses in GPIO_Thread. The biggest part of a project's new code is providing an appropriate task data structure, an initialization function, and the HIGH and LOW functions.</p>

<p>In most cases, no external libraries other than pulsedThread is used. Access to the GPIO hardware is done through memory mapping and reading/writing directly to peripheral registers, or through the /sys pseudo file system for polling. A pair of files, GPIOlowlevel.cpp/.h, contain the constants, macros, and functions for <a href = "./GPIOlowLevel.html">low level access to Raspberry Pi peripherals</a> such as GPIO and PWM. All of the projects include these two files.</p>

<H3>GPIO Thread Projects</H3>
<ol>
<li><a href = "./SimpleGPIO.html">Simple GPIO</a> -- ouputs digital pulses, trains, and infinite trains from a single GPIO pin</li>
<li><a href = "./HX711.html">HX711</a> -- controls an HX711 load cell amplifier, writing clock pulses on one GPIO pin and reading data on another</li>
<li><a href= "./PWM_thread.html">PWM Thread</a> -- controls the Pi's PWM (Pulse Width Modulation) peripheral</li>
</ol>



	




 
/* The 3 parts to running the lever pulling task  
1) The program calling the leverThread object 
	- may be in Python through a Python C++ module that provides an interface to a leverThread object
	- makes an array of unsigned bytes to hold lever position data
	- makes the leverThread object, passing it a pointer to the lever position data, plus some size info
	- sets constant force, sets lever hold params, sets force params if doing force
	-starts a trial 
	- checks a trial to see if it is done. For an uncued trial, this could be while. 
	- is responsible for saving the lever position data in the array before starting another trial
	
2) the leverThread object
	- makes a leverThread struct 
	- receives data from calling program
	- writes to leverThreadStruct shared with the thread function to signal thread
	- makes the array for leverForce data and passes a pointer to that data to the leverThread struct
	
3) the threaded function that works with leverThreadStruct
	- timing controlled by pulsedThread superclass. Can be Trian or Infinite train with circular buffer
	- does the hardware stuff, reading the encoder and outputting force
	
</body>
</html>

